<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>晶体结构动态壁纸</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif;
            background: #0a0a0f;
            color: #e0e0e0;
            display: flex;
            /* 添加flex布局 */
            justify-content: center;
            /* 水平居中 */
            align-items: center;
            /* 垂直居中 */
            min-height: 100vh;
            /* 确保body至少占满整个视口 */
        }

        #container {
            width: 90vw;
            height: 90vh;
            position: relative;
            overflow: hidden;

  
        }

        .crystal-container {
            position: absolute;
            width: 20%;
            height: 50%;
            overflow: hidden;
            cursor: grab;
        }

        .crystal-container:active {
            cursor: grabbing;
        }

        .crystal-label {
            position: absolute;
            bottom: 10px;
            /* 移动到模型下方 */
            left: 50%;
            transform: translateX(-50%);
            background: rgba(20, 20, 30, 0.8);
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 12px;
            z-index: 10;
            backdrop-filter: blur(5px);
            pointer-events: auto;
            /* 允许点击 */
            cursor: pointer;
            transition: all 0.3s ease;
            white-space: nowrap;
            text-align: center;
            min-width: 120px;
        }

        .crystal-label:hover {
            background: rgba(30, 30, 45, 0.9);
            transform: translateX(-50%) translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .crystal-label:active {
            transform: translateX(-50%) translateY(0);
        }

        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #0a0a0f;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 0.5s ease;
        }

        .loader {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(74, 158, 255, 0.3);
            border-radius: 50%;
            border-top-color: #4a9eff;
            animation: spin 1s ease-in-out infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .loading-text {
            color: #b0b0c0;
            font-size: 16px;
            text-align: center;
        }
    </style>
</head>

<body>
    <div id="container">
        <!-- 10个晶体容器将通过JavaScript动态创建 -->
    </div>

    <div class="loading-screen" id="loading-screen">
        <div class="loader"></div>
        <div class="loading-text">Developed by MaJiangla</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // 颜色定义 - 深色模式优化
        const colors = {
            atom1: [1, 0.4, 0.4],      // 亮红色 - 金属原子/阳离子
            atom2: [0.4, 0.7, 1],      // 亮蓝色 - 非金属原子/阴离子
            atom3: [0.4, 1, 0.4],      // 亮绿色 - 氟原子
            atom4: [1, 1, 0.4],        // 亮黄色 - 硫原子
            atom5: [0.8, 0.8, 0.8],    // 浅灰色 - 锌原子/碳原子
            atom6: [0.9, 0.6, 0.2],    // 橙色 - 铜原子
            atom7: [0.6, 0.2, 0.9],    // 紫色 - 硅原子
            atom8: [1, 0.8, 0.2],      // 金黄色 - 氧原子
            bond: [0.7, 0.7, 0.7],     // 浅灰色 - 化学键
            cube: [0.6, 0.6, 0.6]      // 浅灰色 - 立方体框架
        };

        // 晶体结构描述
        const crystalInfo = {
            sc: { name: "简单立方" },
            bcc: { name: "体心立方" },
            fcc: { name: "面心立方" },
            nacl: { name: "氯化钠 (NaCl)" },
            cscl: { name: "氯化铯 (CsCl)" },
            diamond: { name: "金刚石 (C)" },
            caf2: { name: "荧石 (CaF₂)" },
            zns: { name: "闪锌矿 (ZnS)" },
            cu2o: { name: "氧化亚铜 (Cu₂O)" },
            sio2: { name: "二氧化硅 (SiO₂)" }
        };

        // 全局变量
        const crystals = [];

        // 初始化
        function init() {
            createCrystalContainers();

            // 隐藏加载屏幕
            setTimeout(() => {
                document.getElementById('loading-screen').style.opacity = '0';
                setTimeout(() => {
                    document.getElementById('loading-screen').style.display = 'none';
                }, 500);
            }, 1500);

            // 开始动画循环
            animate();
        }

        // 创建10个晶体容器
        function createCrystalContainers() {
            const container = document.getElementById('container');
            const crystalTypes = ['sc', 'bcc', 'fcc', 'nacl', 'cscl',
                'diamond', 'caf2', 'zns', 'cu2o', 'sio2'];

            crystalTypes.forEach((type, index) => {
                // 创建容器
                const div = document.createElement('div');
                div.className = 'crystal-container';
                div.id = `crystal-${type}`;
                div.dataset.type = type;

                // 设置位置
                const row = Math.floor(index / 5);
                const col = index % 5;
                div.style.left = `${col * 20}%`;
                div.style.top = `${row * 50}%`;

                container.appendChild(div);

                // 初始化晶体
                initCrystal(type, div);
            });
        }

        // 初始化单个晶体
        function initCrystal(type, container) {
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0f);

            const width = container.clientWidth;
            const height = container.clientHeight;

            const camera = new THREE.PerspectiveCamera(60, width / height, 0.1, 1000);
            camera.position.set(1.4, 1.4, 1.4);
            camera.lookAt(0, 0, 0);

            const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(width, height);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);

            // 创建旋转组 - 用于自转和手动旋转
            const rotationGroup = new THREE.Group();
            scene.add(rotationGroup);

            // 添加光源 - 固定位置，不随旋转组旋转
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
            scene.add(ambientLight);

            // 主光源始终在斜前方
            const mainLight = new THREE.DirectionalLight(0xffffff, 1);
            mainLight.position.set(5, 10, 7);
            mainLight.castShadow = true;
            scene.add(mainLight);

            // // 补光
            // const fillLight = new THREE.DirectionalLight(0xffffff, 0.3);
            // fillLight.position.set(-5, 5, -7);
            // scene.add(fillLight);

            // 创建立方体框架
            createCubeFrame(rotationGroup);

            // 创建晶体结构
            const crystal = {
                type: type,
                container: container,
                scene: scene,
                camera: camera,
                renderer: renderer,
                rotationGroup: rotationGroup,
                isMouseDown: false,
                lastMouseX: 0,
                lastMouseY: 0,
                // 自转相关
                autoRotation: true,
                autoRotationSpeed: 0.001, // 基础自转速度
                baseRotationSpeed: 0.001, // 保存基础速度
                clickCount: 0, // 点击计数器
                // 手动旋转
                manualRotationX: 0,
                manualRotationY: 0
            };

            // 添加标签（放在最后，确保在最上层）
            const label = document.createElement('div');
            label.className = 'crystal-label';
            label.textContent = crystalInfo[type].name;
            label.dataset.type = type;
            container.appendChild(label);

            // 添加标签点击事件
            label.addEventListener('click', (e) => {
                e.stopPropagation(); // 防止事件冒泡
                crystal.clickCount++;

                // 加速旋转：每点击一次增加速度
                crystal.autoRotationSpeed = crystal.baseRotationSpeed * (1 + crystal.clickCount * 10);

                // 点击4次后重置
                if (crystal.clickCount >= 4) {
                    crystal.clickCount = 0;
                    crystal.autoRotationSpeed = crystal.baseRotationSpeed;

                    // 添加重置动画效果
                    label.style.backgroundColor = 'rgba(74, 158, 255, 0.8)';
                    setTimeout(() => {
                        label.style.backgroundColor = '';
                    }, 300);
                }

                // 添加点击反馈
                label.style.transform = 'translateX(-50%) scale(0.95)';
                setTimeout(() => {
                    label.style.transform = 'translateX(-50%)';
                }, 150);
            });

            // 添加鼠标事件监听
            setupMouseControls(crystal);

            createCrystalStructure(type, rotationGroup);

            crystals.push(crystal);
        }

        // 设置鼠标控制
        function setupMouseControls(crystal) {
            const container = crystal.container;

            container.addEventListener('mousedown', (e) => {
                crystal.isMouseDown = true;
                crystal.lastMouseX = e.clientX;
                crystal.lastMouseY = e.clientY;
                e.preventDefault();
            });

            container.addEventListener('mousemove', (e) => {
                if (!crystal.isMouseDown) return;

                const deltaX = e.clientX - crystal.lastMouseX;
                const deltaY = e.clientY - crystal.lastMouseY;

                crystal.manualRotationY += deltaX * 0.01;
                crystal.manualRotationX += deltaY * 0.01;

                crystal.lastMouseX = e.clientX;
                crystal.lastMouseY = e.clientY;
                e.preventDefault();
            });

            container.addEventListener('mouseup', (e) => {
                crystal.isMouseDown = false;
                e.preventDefault();
            });

            container.addEventListener('mouseleave', (e) => {
                crystal.isMouseDown = false;
                e.preventDefault();
            });

            container.addEventListener('wheel', (e) => {
                e.preventDefault();
                const zoomSpeed = 0.1;
                if (e.deltaY < 0) {
                    crystal.camera.position.multiplyScalar(0.9);
                } else {
                    crystal.camera.position.multiplyScalar(1.1);
                }
            });
        }

        // 创建立方体框架 - 修改：加粗线框
        function createCubeFrame(group) {
            const edges = [
                [0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 1],
                [1, 0, 0, 1, 1, 0], [1, 0, 0, 1, 0, 1],
                [0, 1, 0, 1, 1, 0], [0, 1, 0, 0, 1, 1],
                [0, 0, 1, 1, 0, 1], [0, 0, 1, 0, 1, 1],
                [1, 1, 0, 1, 1, 1], [1, 0, 1, 1, 1, 1], [0, 1, 1, 1, 1, 1]
            ];

            const material = new THREE.LineBasicMaterial({
                color: new THREE.Color(...colors.cube),
                transparent: true,
                opacity: 0.8,
                linecap: 'round',
                linejoin: 'round'
            });

            const geometry = new THREE.BufferGeometry();
            const vertices = [];

            edges.forEach(edge => {
                vertices.push(edge[0] - 0.5, edge[1] - 0.5, edge[2] - 0.5);
                vertices.push(edge[3] - 0.5, edge[4] - 0.5, edge[5] - 0.5);
            });

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));

            const line = new THREE.LineSegments(geometry, material);
            group.add(line);
        }

        // 创建原子
        function createAtom(group, position, color, size) {
            const geometry = new THREE.SphereGeometry(size * 0.1, 24, 24);
            const material = new THREE.MeshStandardMaterial({
                color: new THREE.Color(...color),
                metalness: 0.3,
                roughness: 0.2,
                emissive: new THREE.Color(...color.map(c => c * 0.1))
            });

            const atom = new THREE.Mesh(geometry, material);
            atom.position.set(position[0] - 0.5, position[1] - 0.5, position[2] - 0.5);
            atom.castShadow = true;
            atom.receiveShadow = true;

            group.add(atom);
            return atom;
        }

        // 创建化学键（实线）
        function createBond(group, start, end, color) {
            const length = Math.sqrt(
                Math.pow(end[0] - start[0], 2) +
                Math.pow(end[1] - start[1], 2) +
                Math.pow(end[2] - start[2], 2)
            );

            const geometry = new THREE.CylinderGeometry(0.02, 0.02, length, 8);
            const material = new THREE.MeshStandardMaterial({
                color: new THREE.Color(...color),
                metalness: 0.2,
                roughness: 0.5
            });

            const bond = new THREE.Mesh(geometry, material);

            // 计算中点位置
            const midPoint = [
                (start[0] + end[0]) / 2 - 0.5,
                (start[1] + end[1]) / 2 - 0.5,
                (start[2] + end[2]) / 2 - 0.5
            ];

            bond.position.set(midPoint[0], midPoint[1], midPoint[2]);

            // 计算方向并旋转圆柱体
            const direction = new THREE.Vector3(
                end[0] - start[0],
                end[1] - start[1],
                end[2] - start[2]
            ).normalize();

            bond.quaternion.setFromUnitVectors(
                new THREE.Vector3(0, 1, 0),
                direction
            );

            bond.castShadow = true;
            group.add(bond);
            return bond;
        }

        // 创建虚线化学键（用于体心立方和面心立方对角线） - 修改：减小虚线粗细
        function createDashedBond(group, start, end, color) {
            // 创建虚线效果：创建多个短圆柱体
            const segments = 8;
            const direction = new THREE.Vector3(
                end[0] - start[0],
                end[1] - start[1],
                end[2] - start[2]
            );
            const length = direction.length();
            direction.normalize();

            const segmentLength = length / segments;
            const bondGroup = new THREE.Group();

            for (let i = 0; i < segments; i += 2) {
                const segmentStart = [
                    start[0] + direction.x * i * segmentLength,
                    start[1] + direction.y * i * segmentLength,
                    start[2] + direction.z * i * segmentLength
                ];
                const segmentEnd = [
                    start[0] + direction.x * (i + 1) * segmentLength,
                    start[1] + direction.y * (i + 1) * segmentLength,
                    start[2] + direction.z * (i + 1) * segmentLength
                ];

                const geometry = new THREE.CylinderGeometry(0.015, 0.015, segmentLength, 8); // 修改：从0.02减小到0.015，使虚线更细
                const material = new THREE.MeshStandardMaterial({
                    color: new THREE.Color(...color),
                    metalness: 0.2,
                    roughness: 0.5
                });

                const segmentBond = new THREE.Mesh(geometry, material);

                const midPoint = [
                    (segmentStart[0] + segmentEnd[0]) / 2 - 0.5,
                    (segmentStart[1] + segmentEnd[1]) / 2 - 0.5,
                    (segmentStart[2] + segmentEnd[2]) / 2 - 0.5
                ];

                segmentBond.position.set(midPoint[0], midPoint[1], midPoint[2]);

                const segmentDirection = new THREE.Vector3(
                    segmentEnd[0] - segmentStart[0],
                    segmentEnd[1] - segmentStart[1],
                    segmentEnd[2] - segmentStart[2]
                ).normalize();

                segmentBond.quaternion.setFromUnitVectors(
                    new THREE.Vector3(0, 1, 0),
                    segmentDirection
                );

                bondGroup.add(segmentBond);
            }

            group.add(bondGroup);
            return bondGroup;
        }

        // 创建晶体结构
        function createCrystalStructure(type, group) {
            switch (type) {
                case 'sc':
                    createSimpleCubic(group);
                    break;
                case 'bcc':
                    createBodyCenteredCubic(group);
                    break;
                case 'fcc':
                    createFaceCenteredCubic(group);
                    break;
                case 'nacl':
                    createNaCl(group);
                    break;
                case 'cscl':
                    createCsCl(group);
                    break;
                case 'diamond':
                    createDiamond(group);
                    break;
                case 'caf2':
                    createCaF2(group);
                    break;
                case 'zns':
                    createZnS(group);
                    break;
                case 'cu2o':
                    createCu2O(group);
                    break;
                case 'sio2':
                    createSiO2(group);
                    break;
            }
        }

        // 简单立方 (SC)
        function createSimpleCubic(group) {
            const positions = [
                [0, 0, 0], [1, 0, 0], [0, 1, 0], [0, 0, 1],
                [1, 1, 0], [1, 0, 1], [0, 1, 1], [1, 1, 1]
            ];

            positions.forEach(pos => {
                createAtom(group, pos, colors.atom1, 1);
            });
        }

        // 体心立方 (BCC) - 使用虚线化学键
        function createBodyCenteredCubic(group) {
            const positions = [
                [0, 0, 0], [1, 0, 0], [0, 1, 0], [0, 0, 1],
                [1, 1, 0], [1, 0, 1], [0, 1, 1], [1, 1, 1],
                [0.5, 0.5, 0.5]
            ];

            positions.forEach((pos, index) => {
                createAtom(group, pos, colors.atom1, index === 8 ? 1.1 : 1);

                // 体心原子到顶点的化学键（使用虚线）
                if (index === 8) {
                    for (let i = 0; i < 8; i++) {
                        createDashedBond(group, pos, positions[i], colors.bond);
                    }
                }
            });
        }

        // 面心立方 (FCC) - 添加面对角线（修改：改为虚线）
        function createFaceCenteredCubic(group) {
            // 原子位置
            const positions = [
                [0, 0, 0], [1, 0, 0], [0, 1, 0], [0, 0, 1],
                [1, 1, 0], [1, 0, 1], [0, 1, 1], [1, 1, 1],
                [0.5, 0.5, 0], [0.5, 0, 0.5], [0, 0.5, 0.5],
                [0.5, 0.5, 1], [0.5, 1, 0.5], [1, 0.5, 0.5]
            ];

            positions.forEach(pos => {
                createAtom(group, pos, colors.atom1, 1);
            });

            // 添加面对角线 - 修改：改为虚线
            const faceDiagonals = [
                // 前面 (z=0)
                [[0, 0, 0], [1, 1, 0]],
                [[1, 0, 0], [0, 1, 0]],
                // 后面 (z=1)
                [[0, 0, 1], [1, 1, 1]],
                [[1, 0, 1], [0, 1, 1]],
                // 底面 (y=0)
                [[0, 0, 0], [1, 0, 1]],
                [[1, 0, 0], [0, 0, 1]],
                // 顶面 (y=1)
                [[0, 1, 0], [1, 1, 1]],
                [[1, 1, 0], [0, 1, 1]],
                // 左侧面 (x=0)
                [[0, 0, 0], [0, 1, 1]],
                [[0, 1, 0], [0, 0, 1]],
                // 右侧面 (x=1)
                [[1, 0, 0], [1, 1, 1]],
                [[1, 1, 0], [1, 0, 1]]
            ];

            faceDiagonals.forEach(([start, end]) => {
                // 修改：使用虚线函数而不是Line
                createDashedBond(group, start, end, colors.cube);
            });
        }

        // 氯化钠 (NaCl)
        function createNaCl(group) {
            const clPositions = [
                [0, 0, 0], [0.5, 0.5, 0], [0.5, 0, 0.5], [0, 0.5, 0.5],
                [1, 1, 0], [0.5, 0.5, 1], [0.5, 1, 0.5], [1, 0.5, 0.5],
                [1, 0, 1], [0, 1, 1], [1, 1, 1], [0, 0, 1], [1, 0, 0], [0, 1, 0]
            ];

            const naPositions = [
                [0.5, 0, 0], [0, 0.5, 0], [0, 0, 0.5], [0.5, 0.5, 0.5],
                [1, 0.5, 0], [0.5, 1, 0], [1, 0, 0.5], [0.5, 1, 1],
                [1, 0.5, 1], [0.5, 0, 1], [0, 0.5, 1], [0, 1, 0.5], [1, 1, 0.5]
            ];

            // 创建原子
            clPositions.forEach(pos => {
                createAtom(group, pos, colors.atom2, 0.9);
            });

            naPositions.forEach(pos => {
                createAtom(group, pos, colors.atom1, 0.8);
            });

            // 创建完整的Na-Cl化学键
            naPositions.forEach(naPos => {
                // 检查6个方向上的Cl原子
                const directions = [
                    [0.5, 0, 0], [-0.5, 0, 0],
                    [0, 0.5, 0], [0, -0.5, 0],
                    [0, 0, 0.5], [0, 0, -0.5]
                ];

                directions.forEach(dir => {
                    const clPos = [
                        naPos[0] + dir[0],
                        naPos[1] + dir[1],
                        naPos[2] + dir[2]
                    ];

                    // 检查这个位置是否有Cl原子
                    const hasCl = clPositions.some(cl =>
                        Math.abs(cl[0] - clPos[0]) < 0.01 &&
                        Math.abs(cl[1] - clPos[1]) < 0.01 &&
                        Math.abs(cl[2] - clPos[2]) < 0.01
                    );

                    if (hasCl) {
                        createBond(group, naPos, clPos, colors.bond);
                    }
                });
            });
        }

        // 氯化铯 (CsCl)
        function createCsCl(group) {
            const clPositions = [
                [0, 0, 0], [1, 0, 0], [0, 1, 0], [0, 0, 1],
                [1, 1, 0], [1, 0, 1], [0, 1, 1], [1, 1, 1]
            ];

            const csPositions = [[0.5, 0.5, 0.5]];

            clPositions.forEach(pos => {
                createAtom(group, pos, colors.atom2, 0.9);
            });

            csPositions.forEach(pos => {
                createAtom(group, pos, colors.atom1, 1.1);

                // Cs-Cl化学键
                clPositions.forEach(clPos => {
                    createBond(group, pos, clPos, colors.bond);
                });
            });
        }

        // 金刚石 (Diamond) - 修正化学键
        function createDiamond(group) {
            // 金刚石结构：面心立方 + 4个内部原子
            // 面心立方原子位置
            const fccPositions = [
                [0, 0, 0], [1, 0, 0], [0, 1, 0], [0, 0, 1],
                [1, 1, 0], [1, 0, 1], [0, 1, 1], [1, 1, 1],
                [0.5, 0.5, 0], [0.5, 0, 0.5], [0, 0.5, 0.5],
                [0.5, 0.5, 1], [0.5, 1, 0.5], [1, 0.5, 0.5]
            ];

            // 内部四面体原子位置
            const tetrahedralPositions = [
                [0.25, 0.25, 0.25],
                [0.25, 0.75, 0.75],
                [0.75, 0.25, 0.75],
                [0.75, 0.75, 0.25]
            ];

            // 所有原子位置
            const allPositions = [...fccPositions, ...tetrahedralPositions];

            // 创建所有原子
            allPositions.forEach(pos => {
                createAtom(group, pos, colors.atom5, 1);
            });

            // 金刚石结构的键长
            const bondLength = Math.sqrt(3) / 4; // ≈ 0.433

            // 创建化学键
            // 每个内部原子连接4个最近的原子（面心或顶点）
            tetrahedralPositions.forEach(tetraPos => {
                const distances = fccPositions.map(fccPos => ({
                    pos: fccPos,
                    dist: Math.sqrt(
                        Math.pow(tetraPos[0] - fccPos[0], 2) +
                        Math.pow(tetraPos[1] - fccPos[1], 2) +
                        Math.pow(tetraPos[2] - fccPos[2], 2)
                    )
                }));

                // 按距离排序，取最近的4个
                distances.sort((a, b) => a.dist - b.dist);
                const nearest = distances.slice(0, 4);

                // 创建化学键
                nearest.forEach(item => {
                    if (Math.abs(item.dist - bondLength) < 0.01) {
                        createBond(group, tetraPos, item.pos, colors.bond);
                    }
                });
            });
        }

        // 荧石 (CaF2)
        function createCaF2(group) {
            const caPositions = [
                [0, 0, 0], [1, 0, 0], [0, 1, 0], [0, 0, 1],
                [1, 1, 0], [1, 0, 1], [0, 1, 1], [1, 1, 1],
                [0.5, 0.5, 0], [0.5, 0, 0.5], [0, 0.5, 0.5],
                [0.5, 0.5, 1], [0.5, 1, 0.5], [1, 0.5, 0.5]
            ];

            const fPositions = [
                [0.25, 0.25, 0.25], [0.25, 0.25, 0.75],
                [0.25, 0.75, 0.25], [0.25, 0.75, 0.75],
                [0.75, 0.25, 0.25], [0.75, 0.25, 0.75],
                [0.75, 0.75, 0.25], [0.75, 0.75, 0.75]
            ];

            caPositions.forEach(pos => {
                createAtom(group, pos, colors.atom1, 0.9);
            });

            fPositions.forEach(pos => {
                createAtom(group, pos, colors.atom3, 0.7);
            });

            // 添加Ca-F化学键
            fPositions.forEach(fPos => {
                // 每个F原子连接4个最近的Ca原子
                const distances = caPositions.map(caPos => ({
                    pos: caPos,
                    dist: Math.sqrt(
                        Math.pow(fPos[0] - caPos[0], 2) +
                        Math.pow(fPos[1] - caPos[1], 2) +
                        Math.pow(fPos[2] - caPos[2], 2)
                    )
                }));

                // 按距离排序，取最近的4个
                distances.sort((a, b) => a.dist - b.dist);
                const nearest = distances.slice(0, 4);

                nearest.forEach(item => {
                    if (item.dist < 0.6) {
                        createBond(group, fPos, item.pos, colors.bond);
                    }
                });
            });
        }

        // 闪锌矿 (ZnS)
        function createZnS(group) {
            const sPositions = [
                [0, 0, 0], [1, 0, 0], [0, 1, 0], [0, 0, 1],
                [1, 1, 0], [1, 0, 1], [0, 1, 1], [1, 1, 1],
                [0.5, 0.5, 0], [0.5, 0, 0.5], [0, 0.5, 0.5],
                [0.5, 0.5, 1], [0.5, 1, 0.5], [1, 0.5, 0.5]
            ];

            const znPositions = [
                [0.25, 0.25, 0.25], [0.25, 0.75, 0.75],
                [0.75, 0.25, 0.75], [0.75, 0.75, 0.25]
            ];

            sPositions.forEach(pos => {
                createAtom(group, pos, colors.atom4, 0.9);
            });

            znPositions.forEach(pos => {
                createAtom(group, pos, colors.atom5, 0.8);
            });

            // 添加Zn-S化学键
            znPositions.forEach(znPos => {
                // 每个Zn原子连接4个最近的S原子
                const distances = sPositions.map(sPos => ({
                    pos: sPos,
                    dist: Math.sqrt(
                        Math.pow(znPos[0] - sPos[0], 2) +
                        Math.pow(znPos[1] - sPos[1], 2) +
                        Math.pow(znPos[2] - sPos[2], 2)
                    )
                }));

                // 按距离排序，取最近的4个
                distances.sort((a, b) => a.dist - b.dist);
                const nearest = distances.slice(0, 4);

                nearest.forEach(item => {
                    if (item.dist < 0.6) {
                        createBond(group, znPos, item.pos, colors.bond);
                    }
                });
            });
        }

        // 氧化亚铜 (Cu2O)
        function createCu2O(group) {
            const oPositions = [
                [0, 0, 0], [1, 0, 0], [0, 1, 0], [0, 0, 1],
                [1, 1, 0], [1, 0, 1], [0, 1, 1], [1, 1, 1],
                [0.5, 0.5, 0.5]
            ];

            const cuPositions = [
                [0.25, 0.25, 0.25],
                [0.25, 0.75, 0.75],
                [0.75, 0.25, 0.75],
                [0.75, 0.75, 0.25]
            ];

            oPositions.forEach(pos => {
                createAtom(group, pos, colors.atom8, 1);
            });

            cuPositions.forEach(pos => {
                createAtom(group, pos, colors.atom6, 0.9);
            });

            // 添加Cu-O化学键
            cuPositions.forEach(cuPos => {
                // 连接到最近的顶点O原子
                const vertexO = [
                    cuPos[0] < 0.5 ? 0 : 1,
                    cuPos[1] < 0.5 ? 0 : 1,
                    cuPos[2] < 0.5 ? 0 : 1
                ];

                createBond(group, cuPos, vertexO, colors.bond);

                // 连接到体心O原子
                createBond(group, cuPos, [0.5, 0.5, 0.5], colors.bond);
            });
        }

        // 二氧化硅 (SiO2)
        function createSiO2(group) {
            // Si原子位置（金刚石结构）
            const siPositions = [
                [0, 0, 0], [0.5, 0.5, 0], [0.5, 0, 0.5], [0, 0.5, 0.5],
                [1, 1, 0], [0.5, 0.5, 1], [0.5, 1, 0.5], [1, 0.5, 0.5],
                [1, 0, 1], [0, 1, 1], [1, 1, 1], [0, 0, 1], [1, 0, 0], [0, 1, 0],
                [0.25, 0.25, 0.25], [0.25, 0.75, 0.75],
                [0.75, 0.25, 0.75], [0.75, 0.75, 0.25]
            ];

            // O原子位置 - 位于每对Si原子的中点
            // 首先找到所有Si-Si键
            const bonds = [];
            const oPositions = [];

            for (let i = 0; i < siPositions.length; i++) {
                for (let j = i + 1; j < siPositions.length; j++) {
                    const dist = Math.sqrt(
                        Math.pow(siPositions[i][0] - siPositions[j][0], 2) +
                        Math.pow(siPositions[i][1] - siPositions[j][1], 2) +
                        Math.pow(siPositions[i][2] - siPositions[j][2], 2)
                    );

                    // 如果是最近邻（金刚石结构中Si-Si键长约0.433）
                    if (Math.abs(dist - Math.sqrt(3) / 4) < 0.01) {
                        bonds.push([siPositions[i], siPositions[j]]);

                        // 计算中点作为O原子位置
                        const midPoint = [
                            (siPositions[i][0] + siPositions[j][0]) / 2,
                            (siPositions[i][1] + siPositions[j][1]) / 2,
                            (siPositions[i][2] + siPositions[j][2]) / 2
                        ];

                        oPositions.push(midPoint);
                    }
                }
            }

            // 创建Si原子
            siPositions.forEach(pos => {
                createAtom(group, pos, colors.atom7, 0.8);
            });

            // 创建O原子
            oPositions.forEach(pos => {
                createAtom(group, pos, colors.atom8, 0.6);
            });

            // 创建Si-O化学键
            bonds.forEach(([si1, si2], index) => {
                const oPos = oPositions[index];

                // Si1到O的键
                createBond(group, si1, oPos, colors.bond);

                // Si2到O的键
                createBond(group, si2, oPos, colors.bond);
            });
        }

        // 窗口大小调整处理
        function onWindowResize() {
            crystals.forEach(crystal => {
                const width = crystal.container.clientWidth;
                const height = crystal.container.clientHeight;

                crystal.camera.aspect = width / height;
                crystal.camera.updateProjectionMatrix();
                crystal.renderer.setSize(width, height);
            });
        }

        // 动画循环
        function animate() {
            requestAnimationFrame(animate);

            crystals.forEach(crystal => {
                // 应用手动旋转
                crystal.rotationGroup.rotation.x += crystal.manualRotationX;
                crystal.rotationGroup.rotation.y += crystal.manualRotationY;

                // 重置手动旋转增量
                crystal.manualRotationX = 0;
                crystal.manualRotationY = 0;

                // 应用自转（统一绕Y轴旋转）
                if (crystal.autoRotation && !crystal.isMouseDown) {
                    crystal.rotationGroup.rotation.y += crystal.autoRotationSpeed;
                }

                crystal.renderer.render(crystal.scene, crystal.camera);
            });
        }

        // 启动应用
        init();

        // 添加窗口大小调整监听
        window.addEventListener('resize', onWindowResize);
    </script>
</body>

</html>